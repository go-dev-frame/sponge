package server

import (
	"context"
	"encoding/base64"
	"errors"
	"fmt"
	"net"
	"net/http"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"golang.org/x/crypto/acme"
	"golang.org/x/crypto/acme/autocert"

	"github.com/go-dev-frame/sponge/pkg/app"
	"github.com/go-dev-frame/sponge/pkg/logger"

	"github.com/go-dev-frame/sponge/internal/config"
	"github.com/go-dev-frame/sponge/internal/routers"
)

var _ app.IServer = (*httpServer)(nil)

type httpServer struct {
	httpAddr    string
	httpsAddr   string
	httpServer  *http.Server
	httpsServer *http.Server
	tlsEnabled  bool
}

// Start http/https service
func (s *httpServer) Start() error {
	if s.tlsEnabled {
		errCh := make(chan error, 2)

		go func() {
			errCh <- listenAndServe(s.httpServer)
		}()

		go func() {
			errCh <- listenAndServeTLS(s.httpsServer)
		}()

		var firstErr error
		for i := 0; i < 2; i++ {
			if err := <-errCh; err != nil {
				if firstErr == nil {
					firstErr = err
				} else {
					logger.Error("http server encountered multiple errors", logger.Err(err))
				}
			}
		}

		return firstErr
	}

	if err := listenAndServe(s.httpServer); err != nil {
		return err
	}

	return nil
}

// Stop http/https service
func (s *httpServer) Stop() error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	var firstErr error
	if err := s.httpServer.Shutdown(ctx); err != nil {
		firstErr = err
	}

	if s.tlsEnabled && s.httpsServer != nil {
		if err := s.httpsServer.Shutdown(ctx); err != nil && !errors.Is(err, context.Canceled) {
			if firstErr == nil {
				firstErr = err
			} else {
				logger.Error("https server shutdown reported additional error", logger.Err(err))
			}
		}
	}

	return firstErr
}

// String provides a human readable description of listener addresses.
func (s *httpServer) String() string {
	if s.tlsEnabled {
		return fmt.Sprintf("http service redirecting on %s and https service address %s", s.httpAddr, s.httpsAddr)
	}
	return "http service address " + s.httpAddr
}

// NewHTTPServer creates an HTTP server with optional automatic TLS.
func NewHTTPServer(cfg config.HTTP, opts ...HTTPOption) app.IServer {
	o := defaultHTTPOptions()
	o.apply(opts...)

	if o.isProd {
		gin.SetMode(gin.ReleaseMode)
	} else {
		gin.SetMode(gin.DebugMode)
	}

	appHandler := o.handler
	if appHandler == nil {
		appHandler = routers.NewRouter()
	}

	readTimeout := secondsToDuration(cfg.ReadTimeout)
	writeTimeout := secondsToDuration(cfg.WriteTimeout)
	idleTimeout := secondsToDuration(cfg.IdleTimeout)

	httpSrv := &http.Server{
		Addr:           fmt.Sprintf(":%d", cfg.Port),
		Handler:        appHandler,
		ReadTimeout:    readTimeout,
		WriteTimeout:   writeTimeout,
		IdleTimeout:    idleTimeout,
		MaxHeaderBytes: 1 << 20,
	}

	domains := filterDomains(cfg.TLS.Domains)
	tlsEnabled := len(domains) > 0

	var (
		httpsSrv  *http.Server
		httpsAddr string
	)
	if tlsEnabled {
		manager := buildAutocertManager(cfg, domains)
		httpSrv.Handler = manager.HTTPHandler(http.HandlerFunc(httpRedirectHandler))

		httpsSrv = &http.Server{
			Addr:           fmt.Sprintf(":%d", cfg.HTTPSPort),
			Handler:        appHandler,
			ReadTimeout:    readTimeout,
			WriteTimeout:   writeTimeout,
			IdleTimeout:    idleTimeout,
			MaxHeaderBytes: 1 << 20,
			TLSConfig:      manager.TLSConfig(),
		}
		httpsAddr = httpsSrv.Addr

		logger.Info("automatic TLS enabled", logger.String("http_addr", httpSrv.Addr), logger.String("https_addr", httpsSrv.Addr), logger.Any("domains", domains))
	} else {
		logger.Info("automatic TLS disabled", logger.String("http_addr", httpSrv.Addr))
	}

	return &httpServer{
		httpAddr:    httpSrv.Addr,
		httpsAddr:   httpsAddr,
		httpServer:  httpSrv,
		httpsServer: httpsSrv,
		tlsEnabled:  tlsEnabled,
	}
}

// delete the templates code start

// NewHTTPServer_pbExample creates a new web server
func NewHTTPServer_pbExample(addr string, opts ...HTTPOption) app.IServer { //nolint
	o := defaultHTTPOptions()
	o.apply(opts...)

	if o.isProd {
		gin.SetMode(gin.ReleaseMode)
	} else {
		gin.SetMode(gin.DebugMode)
	}

	router := routers.NewRouter_pbExample()
	server := &http.Server{
		Addr:           addr,
		Handler:        router,
		MaxHeaderBytes: 1 << 20,
	}

	return &httpServer{
		addr:   addr,
		server: server,
	}
}

// delete the templates code end
